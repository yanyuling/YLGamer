
1.GLSL 的数据类型遵循与C的数据类型
	1.有数组(可多维数组)，可通过length() 函数获取数组的长度<类似于Java>
	2.结构体
	3.向量、矩阵的数据结构也能使用length()函数，向量的返回分量的个数、矩阵的长度为列数、三者都可以通过
	  []来读取数据

2.GLSL 的语句
	1.着色器的真正工作是计算数值以及完成一些决策工作。与 C++ 中的形式类似，GLSL也提供了大量的操作符，
	  来实现各种数值计算所需的算术操作，以及一系列控制着色器运行的逻辑操作

	2.向量相乘得到 逐分量相乘后的新向量，矩阵乘法则是数学运算上的矩阵相乘
	3.控制语句 <C的控制逻辑啦>
		if 
		else

		switch：支持fall—through ，如果一个case中没有break，则会只需执行下面的case
		for
		while
		do ... while
		break 
		continue 
		return [ 结果 ]
		discard 丢弃当前的片元，终止着色器的执行。discard 语句只能用于片元着色器中
				<只适用于片元着色器中，片元着色器的运行会在 discard 语句的位置上立即终止>

	4.函数
		函数的声明形式类似于C、只是变量名需要添加访问修饰符

		函数至少要做到前项声明<和C++规则一直，否则会报错>，参数修饰符如下：
			in 将数据拷贝到函数中（如果没有指定修饰符，默认这种形式）	//默认类型
			const in 将只读数据拷贝到函数中
			out 从函数中获取数值（因此输入函数的值是未定义的）
			inout 将数据拷贝到函数中，并且返回函数中修改的数据

	5.预处理命令
		预处理器命令 			描述

		#define
		#undef			控制常量与宏的定义，与 C 语言的预处理器命令类似

		#if
		#ifdef
		#ifndef			代码的条件编译，与 C 语言的预处理器命令和 defi ned 操作符均类似。
		#else 			条件表达式中只可以使用整数表达式或者 #define 定义的值
		#elif
		#endif			

		#error text 	强制编译器将text文字内容（直到第一个换行符为止）插入到着
						色器的信息日志当中

		#pragma options 	控制编译器的特定选项
		#extension options 	设置编译器支持特定 GLSL 扩展功能
		#version number 	设置当前使用的 GLSL 版本名称
		#line options 		设置诊断行号

	    GLSL中的宏定义不像C中支持字符串替换，但是提供了一些预定义的宏，用来记录一些诊断信息
	    #pragma 命令可以向编译器传递附加信息，并在着色器代码编译时设置一些额外属性。
	    #pragma optimize(on) 	启用编译器优化 <默认启用>
	    #pragma optimize(off) 	禁用编译器优化
	    #pragma debug(on) 		开启调试
	    #pragma debug(off) 		关闭调试<默认关闭>


	6.数据块接口
		uniform b { // "uniform" or "in" or "out" or "buffer"
			vec4 v1; // list of variables
			bool v2; // ...
		} //访问 v1,v2 




	7.
	8.
	9.

C4 像素和帧缓存
	4.1.OpenGL系统中通常包含的缓存类型：
		a.一个或者多个可用的颜色缓存；通常是进行绘制的缓存对象，包含rgba等颜色信息
		b.深度缓存；为每个像素保存一下深度值，用来判断三维空间中物体的可见性
		c.模板缓存；可以用来限制屏幕特定区域的绘制

	4.2 清楚缓存；
		每一帧渲染完成以后，接下来的操作就是清除缓存，为下一帧的渲染和缓存注入做准备<每一帧都执行>

	4.2.2 缓存的掩码；


	4.4 多重采样
